#!/usr/bin/env ruby
# Copyright muflax <mail@muflax.com>, 2011
# License: GNU GPL 3 <http://www.gnu.org/copyleft/gpl.html>

require "highline"
require "mastodon"
require "timetrap"

class Fume
  # todo files
  TODO_DIR   = File.join(Dir.home, "/spoiler/todo")
  LOG        = File.join(TODO_DIR, "fume.log")
  TODO       = File.join(TODO_DIR, "fume.txt")

  # other tools/files used
  PRE_FILTER = "gtd_pre_filter"
  SIGNAL     = File.join(Dir.home, "/in/scripts/fume/signal.wav")

  def initialize time
    @time = if nil? then 10..20 else time end
    @h = HighLine.new
    @log = File.open(LOG, "a")
    @entries = []
    @times = [:today, :week, :month, :total]
    
    reload_todo
    
    # initialize timetrap
    Timetrap::CLI.args = Getopt::Declare.new("#{Timetrap::CLI::USAGE}")
  end

  def reload_todo
    @todo = Mastodon.new(File.readlines(TODO))
  end
  
  def show_todo
    puts "  -> Incoming transmission! <-"

    # let's grab all the necessary data
    reload_todo
    contexts      = @todo.contexts
    ctx_length    = length_of_longest_in contexts

    quotas        = get_quotas contexts
    global_quota  = quotas[:all]
    targets       = get_targets contexts
    global_weight = targets.reduce(0) {|sum, (t, w)| sum+w}
    
    todos         = @todo.todos.sort
    @entries      = get_entries todos

    # let's make some sausage
    @entries.each_with_index do |entry, i|
      ctx          = entry.contexts[0]
      quota        = quotas[ctx]
      target       = targets[ctx]
      weight       = target.to_f / global_weight
      repeated_cxt = (i > 0 && @entries[i-1].contexts[0] == ctx)

      ratios = []
      @times.each do |time|
        ratio =
          unless global_quota[time].zero?
            (quota[time].to_f / global_quota[time])
          else
            0.0
          end
        diff = ratio / weight
        color =
          if repeated_cxt
            :light_black
          elsif diff > 0.8
            :green
          elsif diff > 0.5
            :brown
          else
            :red
          end
        ratios << colorize("%3.0f%%" % [ratio * 100], color)
      end
      
      puts "%{id} %{weight} %{rating} %{context} %{id} #{entry.text}" % {
        id: colorize("<%02d>" % (i+1), :purple),
        context: colorize("%#{ctx_length+1}s" % ("@#{ctx}"),
                          repeated_cxt ? :light_black : :brown),
        rating: "[#{ ratios.join ' | ' }]",
        weight: colorize("%3dx" % target, repeated_cxt ? :light_black : :white),
      }
    end

    # summary
    hours = []
    @times.each do |time|
      hour = global_quota[time] / 3600.to_f
      hours <<
        if hour < 100
          "%4.1f" % hour
        else
          "%4.0f" % hour
        end
    end
    
    puts "sum: %3dx [#{hours.join ' | '}]" % global_weight
  end

  def length_of_longest_in(list)
    list.max do |a, b| 
      a.to_s.length <=> b.to_s.length
    end.to_s.length
  end
  
  # filter out meta entries
  def get_entries todos
    todos.
      select{|t| (get_weight t).nil?}.
      select{|t| not t.contexts.include? "broken"}.
      select{|t| not t.contexts.empty?}
  end
  
  def get_targets contexts
    targets = {}

    contexts.each do |context|
      todos = @todo.find_context context

      # try to find an entry with !weight declaration or default to 1
      weight = 1
      todos.each do |todo|
        if (w = get_weight todo)
          weight = w
          break
        end
      end
      targets[context] = weight
    end
    
    return targets
  end

  def get_weight todo
    if (m = todo.text.match /(^ | \s+)! (?<weight>\d+) (\s+|$)/x)
      m[:weight].to_i
    else
      nil
    end
  end


  def get_quotas contexts
    intervals = {
      today: "-s '24 hours ago'",
      week:  "-s '7 days ago'",
      month: "-s 'first day this month'",
      total: ""
    }
    quotas = {}

    # quota for individual contexts
    contexts.each do |context|
      quota = {}
      intervals.each do |time, opt|
        Timetrap::CLI.parse "#{context} #{opt}"
        quota[time] =
          begin
            entries = Timetrap::CLI.selected_entries
            entries.inject(0) {|m, e| m += e.duration}
          rescue
            0
          end
      end
      quotas[context] = quota
    end

    # global quota
    global_quota = {}
    @times.each do |time|
      global_quota[time] = quotas.values.reduce(0){|s,v| s+v[time]}
    end
    quotas[:all] = global_quota
    
    return quotas
  end

  def run
    puts "Starting time machine."
    puts "River of time will be fished every #{@time.begin} to #{@time.end} minutes..."

    while true
      begin
        question_me
        
        # wait for next round...
        puts
        puts "Time machine is recharging..."
        sleep @time.to_a.sample * 60

        system "clear"
        system "mplayer -really-quiet #{SIGNAL} &"
        puts "#{colorize("-> BZZZ <-".center(30), :red)}\a"
      rescue Interrupt
        puts "Time machine boggled, recalibrating..."
      end
    end
  end

  def question_me
    while true
      show_todo
      
      puts
      print "#{keywordify("suggest", :green)} "
      print "#{keywordify("choose", :green)} "
      print "#{keywordify("refresh", :green)} "
      print "#{keywordify("keep on working", :green)} "
      print "#{keywordify("out", :green)} "
      print "#{keywordify("quit", :red)}"
      puts
      input = @h.ask("What do you want to do next? ") do |q|
        q.in = %w{s c r k o q}
        q.character = true
      end
      
      case input
      when "s"
        suggest
      when "c"
        choose
      when "q"
        exit 0
      when "r"
        system "clear"
        next
      when "k"
        break
      when "o"
        timetrap "out"
        next
      end
      
      # normal execution, done here
      break
    end
  end

  def timetrap cmd
    Timetrap::CLI.parse cmd
    Timetrap::CLI.invoke
  end

  def keywordify string, color
    "(#{colorize(string[0], color)})#{string[1..-1]}"
  end

  def suggest
    # pick items until a suggestion works
    while true
      id = suggest_entry

      if id.nil?
        puts "Nothing to do. Sorry."
        return
      end
      
      puts "What about #{pre_filter @entries[id]}?"
      print "#{keywordify("sure", :green)} "
      print "#{keywordify("nope", :red)}"
      input = @h.ask(" ") do |q|
        q.in = %w{s n}
        q.character = true
      end
      
      case input
      when "s"
        work_on id
        return
      when "n"
        procrastinate_on id
      end
    end
  end

  def suggest_entry
    # TODO base suggestion on current quota
    rand @entries.size
  end
    
  def choose
    id = @h.ask("What item do you want? ", Integer) {|q| q.in = 1..@entries.size}
    work_on (id - 1)
  end

  def pre_filter string
    %x{echo '#{string}' | #{PRE_FILTER}}.strip
  end

  def work_on id
    item = @entries[id]
    puts "Working on #{pre_filter(item.to_s)}..."
    @log.write "#{Time.now.strftime("%s")} #{item.to_s}"
    
    # extract context the item is in for timetrap
    context = item.contexts.join " "
    unless context.empty?
      timetrap "sheet #{context}"

      # add a task
      task = @h.ask("Care to name a specific task? [ENTER to skip]")
      unless task.empty?
        timetrap "in #{item} - #{task}"
      else
        timetrap "in #{item}"
      end
    else
      puts "No context found. Aborting."
    end
  end

  def procrastinate_on id
    # FIXME translate IDs or something...
    puts "Transmission error detected. Requesting retry..."
    # system "#{FUMETXT} append #{id} @broken"
  end

  Colors = {
    none:"",
    black:"\033[0;30m",
    red:"\033[0;31m",
    green:"\033[0;32m",
    brown:"\033[0;33m",
    blue:"\033[0;34m",
    purple:"\033[0;35m",
    cyan:"\033[0;36m",
    grey:"\033[0;37m",
    light_black:"\033[1;30m",
    light_red:"\033[1;31m",
    light_green:"\033[1;32m",
    light_brown:"\033[1;33m",
    light_blue:"\033[1;34m",
    light_purple:"\033[1;35m",
    light_cyan:"\033[1;36m",
    white:"\033[1;37m",
    reset:"\033[0m",
  }

  def colorize(str, name)
    "#{Colors[name]}#{str}#{Colors[:reset]}"
  end
end

f = Fume.new 10..20
f.run
